## 開発に関して(一般)
___
- about に基づいてコーディング
    - これ結構効率良さげ、コーディング時に迷わない。
- コーディングする前にもう少し細かく実装の流れを書き出した方がいいかも．
    - 次になにを実装すべきかとか見えるので，効率化できそう．
    - 今回はゲームのフローを書き出したけど，実際はゲームフロー通りに実装していった方が良いのか，別に実装した方がいいのかとかもう少し考える．
        - 今回，デバッグする時に結果がわかりにくかったので，『清算』フェーズから実装した方がよかったかも．
- 勝敗に関して，テストは必要．
    - デバッグはプレイしながらやろうと思ったけど，細かな修正時もいちいちプレイしてられない．
    - どうするか考える．

## ゲームフローに関して
___
- 各インスタンス生成
- プレイヤーのベット金額を決定する ***
- プレイヤーにカードを配る ***
- ディーラーにカードを配る
    - 内一枚は伏せる
    - A の場合、インシュランス選択 ***
    - ブラックジャックだった場合のみオープンする
- プレイヤーのアクション ***
    - insurance に関して
        - BJ でない　かつ　bet ins = ベット額没収
        - BJ でない　かつ　no ins = 何もしない
        - BJ かつ　bet ins = ３倍リターン
        - BJ かつ　no ins = 何もしない．
        - insurance した時は player.bet_insurance = True
        - 金額の調整は最後の精算時にまとめて行う．
    - surrender に関して
        - surrender した時は insurance 同様，player.bet_surrender = True
        - 金額の調整は最後の精算時にまとめて行う．
- ディーラーのアクション
    - 17 以上になるまで hit
- 清算
    - 両方 BJ
        - Push
    - プレイヤーのみ BJ
        - pay 3 to 2 or pay 6 to 5
    - ディーラーのみ BJ
        - bet 額没収
    - 両方 burst していない場合
        - 大きい方の勝ち
    - プレイヤーが　burst
        - bet 額没収
    - ディーラーが burst
        - burst していないプレイヤーのみ　勝利．
(*** はプレイヤー人数に応じてループする)

## クラスに関して
___
- デッキクラス
    - プロパティ
        - デッキサイズ
        - (Joker 含むか(Black Jack では使用しないが、汎用性のため))
    - メソッド
        - デッキ生成(初期化)
        - ドロー
        - シャッフル
        - (確率計算・カウンティング)

- プレイヤークラス
    - プロパティ
        - バンクロール
        - ハンド
        - 名前
            - もっとプロフィール情報をつけても面白いかも．
            - DB 情報とひもづける todo
    - メソッド
        - ベット ~~(強制なので不要？？)~~
        - (S)スタンド
            - ターン終了
        - (H)ヒット
            - 一枚追加．S,H から選択
        - (D)ダブル
            - bet = bet * 2
            - 次のアクションで終了 かつ (ヒット or スタンド)
        - (P)スプリット　***
            - 同じ数字の時のみ．手札配列の変形
            - エースのスプリットの場合はブラックジャックにはならない．
        - (I)インシュランス ***
            - ディーラのカードが A の時のみ．
            - 最初の bet の半額を bet. 配当は 3 倍
        - (U)サレンダー ***
            - bet の半額を返却．勝負に参加しない．
        ~~*** は考え中、メソッドでなくて、イベントとして関数化してもいいかも~~
        main 処理の途中で行うことにした．surrender は，予定通りメソッドに組み込む．

- ディーラークラス
    - プロパティ
        - ハンド
    - メソッド
        - アクション
            - ハンドのスコア確認 (calc_hand)
                - 17 以上で stand (17 の場合も含む)
                - 17 以下で hit 
        
## ゲームサーバーに関して(参考URL)
___
- [pythonのgeventとやらでwebsocket](https://blanktar.jp/blog/2014/05/python-gevent-websocket)
- [WebSocketsでチャットを作ってみる！](http://python.matrix.jp/pages/web/chat_sample.html)
- [【JavaScript入門】誰でも分かるWebSocketによるデータ送受信の方法](https://www.sejuku.net/blog/70583)


## 実装ログ
___

## 7/10
- pyBlackJack.py をばらして、web app に流用できるような形にしたい
- about.txt に基づいてコーディング
    - これ結構効率良さげ、コーディング時に迷わない。
- 次回
    - プレーヤーのアクションから始める
    - 一通り CLI でプレイできるようにしたい。

## 7/31
- プレイヤーアクション選択時に実行可能アクションをフラグとして関数に渡す． 
    - 辞書型にして， ** をつけると，"引数": "値" と認識して代入してくれる．(超便利)
- プレイヤークラスのメソッドの実装．
    - split, insurance　はメソッドから外し，split のみゲームの処理の一部として実装した．
- 次回
    - insurance, surrender の実装
    - ディーラーのアクション以降の実装

## 8/7
- 前回 (7/31) の実装に関して， Player クラスの hit メソッド実行時に， ```self.hand.append(deck.draw())``` みたいにしてるのがなんか違和感．インスタンスのスコープはどうなってるの？
- y/n とか キー入力を求める時の，誤入力に関するエラーハンドリングはどうする？？
- insurance に関して
    - insurance 可能タイミングで，プレイヤーに y/n で選択させる．
    - 清算フェーズで フラグが立っているプレイヤーはディーラーのハンドによって処理する．
- ベット金額決定時のリファクタリング
    - ```for i in range(players):``` みたいな感じになってたので，```for p in players:``` に変更．
- Player クラスの bet メソッドに関して
    - メソッド実行時にバンクロールから bet 額を差し引いているが，これは清算時に差し引きでもいいかも．
        - そのほうがいいっぽいからそうした．(insurance もそんな感じの実装になりそうだから．)
- player_bet_amount に関して
    - いる？？？
    - player クラスにひもづけてるからいらない気がする．
        - 結局いらんっぽいから消した．
- バンクロールに関して
    - これインスタンス生成時に 1000 で初期化してるけど，最終的にどうするの
    - web ゲームにしたいから，DB 連携を想定してる．
    - 案１: player クラスのコンストラクタ引数にとって，DB から読む
        - 名前，そのほかの情報にかんしても同様にする．
- 次回
    - 恐らく CLI ver は実装できたので，デバッグしたい．
    - flask なりを使って web 上で CLI の操作をできるようにしたい．
        - これができると，あとは表示を変更するだけなので，勝ち．
        - if, for を使って表示させるボタンを変更．
        - とりあえず 1 ゲームプレイできるようにして，DB 連携させる．
        - DB 連携できたら，うまいことして複数回プレイできるようにする．
        - プラットフォームは　heroku を使いたい
            - 特に理由はないが，無料枠で賄えそうなので．
            - ゲームサーバーと http サーバ間で http リクエストの送受信を行う感じ？？
                - 正解がイメージできてない感じがするので，もっとググる．

## 8/13
- 今後の流れ
    1. CLI でソケット通信できる状態にまでする．
    2. Django で web app 化する

## 8/21
- クライアント側の websocket 実装を javascript で，サーバー側の実装を Python でやってみる．
- SS の PC でなぜか gunicorn コマンドが使えなかったので，なんとか原因を探りたい．

## 8/28 前半 (SS)
- 色々実験してみた．
- インスタンスのスコープに関して
```python
class A:
    def function_A(self):
        print("call function_A")

class B:
    def function_B(self):
        print("call function_B")
    def call_A(self):
        a.function_A()

if __name__ == "__main__":
    a = A()
    a.function_A()
    # call function_A

    b = B()
    b.function_B()
    # call function_B

    b.call_A()
    # call function_A
    # ↑は同じファイル内だから呼び出せる．別ファイルから import してる場合は無理．
```
- ソケット使用時の入力待ち状態の振る舞いに関して
```python
@app.route('/pipe')
def pipe():
    if request.environ.get('wsgi.websocket'):
        ws = request.environ['wsgi.websocket']
        while True:
            # ここに game.py の内容を書く．コマンド入力が欲しいときは message = ws.receive() で入力待ち状態に移行する．
            print("message 受信前")
            message = ws.receive()
            print("message 受信後")
            print(message)
            # ws.send("test message")
    return
```
こうすると，
`message = ws.receive()`
の箇所で，message 受信前のメッセージが出てストップする．ので，入力待ち状態に入っていることがわかる．

- スクリプトファイルの実行とディレクトリ構造に関して

`code1.py`
```python
# import だけで 同階層にある code2 の スクリプトが実行される
import code2

# 関数を呼び出す場合はいつも通り
code2.fun1()

# 別階層のスクリプトを実行する場合
import testcode.code3

# 別階層のファイルの変数を参照する場合．
print(testcode.code3.cd3)
```
`ディレクトリ構造`
```
TestProject
|--code1.py
|--code2.py
|--testcode
|  |--code3.py
```
- 次回修正するエラー
    - `server.py` に `game.py` のゲーム処理をコピーしたけど，実行されるのは`pipe()` 関数なので，スコープの問題で `not defined` になる．
    - `game.py` の処理をまるごと関数にして，引数に ws をとったらどう？

## 8/28 後半
- クラス定義やらゲーム処理やらを全部 main 関数にまとめたら解決。python のスコープの問題だった。
>- 次回修正するエラー
>    - `server.py` に `game.py` のゲーム処理をコピーしたけど，実行されるのは`pipe()` 関数なので，スコープの問題で `not defined` になる．
>    - `game.py` の処理をまるごと関数にして，引数に ws をとったらどう？
- html のボタンと server 側のコマンドを結びつけた。
    - ブラウザ上で hit stand コマンドを入力可能になった
    - hit stand 以外のコマンドは次回追加する。
- 次回
    - ほかのボタンの実装。
    - ターミナルに表示される内容をブラウザ上で表できるようにする。
