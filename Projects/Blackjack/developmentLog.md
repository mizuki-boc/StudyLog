## 開発に関して(一般)
___
- about に基づいてコーディング
    - これ結構効率良さげ、コーディング時に迷わない。
- コーディングする前にもう少し細かく実装の流れを書き出した方がいいかも．
    - 次になにを実装すべきかとか見えるので，効率化できそう．
    - 今回はゲームのフローを書き出したけど，実際はゲームフロー通りに実装していった方が良いのか，別に実装した方がいいのかとかもう少し考える．
        - 今回，デバッグする時に結果がわかりにくかったので，『清算』フェーズから実装した方がよかったかも．
- 勝敗に関して，テストは必要．
    - デバッグはプレイしながらやろうと思ったけど，細かな修正時もいちいちプレイしてられない．
    - どうするか考える．
- データベースは firebase 使ってみたい
    - 参考になりそうなリンク
        - [Python で Google Firebase の Cloud Firestore （クラウド・ファイアストア）を使ってみる](https://www.kkaneko.jp/tools/nosql/pythonfirebase.html)
        - [公式](https://firebase.google.com/docs/firestore/quickstart?hl=ja#python)

## 目次
- [ゲームフローに関して](#ゲームフローに関して)
- [クラスに関して](#クラスに関して)
- [ゲームサーバーに関して](#ゲームサーバーに関して)
- [実装ログ](#実装ログ)
- [今回の反省点](#今回の反省点)

## ゲームフローに関して
___
- 各インスタンス生成
- プレイヤーのベット金額を決定する ***
- プレイヤーにカードを配る ***
- ディーラーにカードを配る
    - 内一枚は伏せる
    - A の場合、インシュランス選択 ***
    - ブラックジャックだった場合のみオープンする
- プレイヤーのアクション ***
    - insurance に関して
        - BJ でない　かつ　bet ins = ベット額没収
        - BJ でない　かつ　no ins = 何もしない
        - BJ かつ　bet ins = ３倍リターン
        - BJ かつ　no ins = 何もしない．
        - insurance した時は player.bet_insurance = True
        - 金額の調整は最後の精算時にまとめて行う．
    - surrender に関して
        - surrender した時は insurance 同様，player.bet_surrender = True
        - 金額の調整は最後の精算時にまとめて行う．
- ディーラーのアクション
    - 17 以上になるまで hit
- 清算
    - 両方 BJ
        - Push
    - プレイヤーのみ BJ
        - pay 3 to 2 or pay 6 to 5
    - ディーラーのみ BJ
        - bet 額没収
    - 両方 burst していない場合
        - 大きい方の勝ち
    - プレイヤーが　burst
        - bet 額没収
    - ディーラーが burst
        - burst していないプレイヤーのみ　勝利．
(*** はプレイヤー人数に応じてループする)

## クラスに関して
___
- デッキクラス
    - プロパティ
        - デッキサイズ
        - (Joker 含むか(Black Jack では使用しないが、汎用性のため))
    - メソッド
        - デッキ生成(初期化)
        - ドロー
        - シャッフル
        - (確率計算・カウンティング)

- プレイヤークラス
    - プロパティ
        - バンクロール
        - ハンド
        - 名前
            - もっとプロフィール情報をつけても面白いかも．
            - DB 情報とひもづける todo
    - メソッド
        - ベット ~~(強制なので不要？？)~~
        - (S)スタンド
            - ターン終了
        - (H)ヒット
            - 一枚追加．S,H から選択
        - (D)ダブル
            - bet = bet * 2
            - 次のアクションで終了 かつ (ヒット or スタンド)
        - (P)スプリット　***
            - 同じ数字の時のみ．手札配列の変形
            - エースのスプリットの場合はブラックジャックにはならない．
        - (I)インシュランス ***
            - ディーラのカードが A の時のみ．
            - 最初の bet の半額を bet. 配当は 3 倍
        - (U)サレンダー ***
            - bet の半額を返却．勝負に参加しない．
        ~~*** は考え中、メソッドでなくて、イベントとして関数化してもいいかも~~
        main 処理の途中で行うことにした．surrender は，予定通りメソッドに組み込む．

- ディーラークラス
    - プロパティ
        - ハンド
    - メソッド
        - アクション
            - ハンドのスコア確認 (calc_hand)
                - 17 以上で stand (17 の場合も含む)
                - 17 以下で hit 
        
## ゲームサーバーに関して
___
- [pythonのgeventとやらでwebsocket](https://blanktar.jp/blog/2014/05/python-gevent-websocket)
- [WebSocketsでチャットを作ってみる！](http://python.matrix.jp/pages/web/chat_sample.html)
- [【JavaScript入門】誰でも分かるWebSocketによるデータ送受信の方法](https://www.sejuku.net/blog/70583)

## リファクタリング対象
___
- 関数の名前
- json のフォーマット
- 結果メッセージ (is_player_win) を pop_message と統一する


## 実装ログ
___

### 7/10
- pyBlackJack.py をばらして、web app に流用できるような形にしたい
- about.txt に基づいてコーディング
    - これ結構効率良さげ、コーディング時に迷わない。
- 次回
    - プレーヤーのアクションから始める
    - 一通り CLI でプレイできるようにしたい。

### 7/31
- プレイヤーアクション選択時に実行可能アクションをフラグとして関数に渡す． 
    - 辞書型にして， ** をつけると，"引数": "値" と認識して代入してくれる．(超便利)
- プレイヤークラスのメソッドの実装．
    - split, insurance　はメソッドから外し，split のみゲームの処理の一部として実装した．
- 次回
    - insurance, surrender の実装
    - ディーラーのアクション以降の実装

### 8/7
- 前回 (7/31) の実装に関して， Player クラスの hit メソッド実行時に， ```self.hand.append(deck.draw())``` みたいにしてるのがなんか違和感．インスタンスのスコープはどうなってるの？
- y/n とか キー入力を求める時の，誤入力に関するエラーハンドリングはどうする？？
- insurance に関して
    - insurance 可能タイミングで，プレイヤーに y/n で選択させる．
    - 清算フェーズで フラグが立っているプレイヤーはディーラーのハンドによって処理する．
- ベット金額決定時のリファクタリング
    - ```for i in range(players):``` みたいな感じになってたので，```for p in players:``` に変更．
- Player クラスの bet メソッドに関して
    - メソッド実行時にバンクロールから bet 額を差し引いているが，これは清算時に差し引きでもいいかも．
        - そのほうがいいっぽいからそうした．(insurance もそんな感じの実装になりそうだから．)
- player_bet_amount に関して
    - いる？？？
    - player クラスにひもづけてるからいらない気がする．
        - 結局いらんっぽいから消した．
- バンクロールに関して
    - これインスタンス生成時に 1000 で初期化してるけど，最終的にどうするの
    - web ゲームにしたいから，DB 連携を想定してる．
    - 案１: player クラスのコンストラクタ引数にとって，DB から読む
        - 名前，そのほかの情報にかんしても同様にする．
- 次回
    - 恐らく CLI ver は実装できたので，デバッグしたい．
    - flask なりを使って web 上で CLI の操作をできるようにしたい．
        - これができると，あとは表示を変更するだけなので，勝ち．
        - if, for を使って表示させるボタンを変更．
        - とりあえず 1 ゲームプレイできるようにして，DB 連携させる．
        - DB 連携できたら，うまいことして複数回プレイできるようにする．
        - プラットフォームは　heroku を使いたい
            - 特に理由はないが，無料枠で賄えそうなので．
            - ゲームサーバーと http サーバ間で http リクエストの送受信を行う感じ？？
                - 正解がイメージできてない感じがするので，もっとググる．

### 8/13
- 今後の流れ
    1. CLI でソケット通信できる状態にまでする．
    2. Django で web app 化する

### 8/21
- クライアント側の websocket 実装を javascript で，サーバー側の実装を Python でやってみる．
- SS の PC でなぜか gunicorn コマンドが使えなかったので，なんとか原因を探りたい．

### 8/28 前半 (SS)
- 色々実験してみた．
- インスタンスのスコープに関して
```python
class A:
    def function_A(self):
        print("call function_A")

class B:
    def function_B(self):
        print("call function_B")
    def call_A(self):
        a.function_A()

if __name__ == "__main__":
    a = A()
    a.function_A()
    # call function_A

    b = B()
    b.function_B()
    # call function_B

    b.call_A()
    # call function_A
    # ↑は同じファイル内だから呼び出せる．別ファイルから import してる場合は無理．
```
- ソケット使用時の入力待ち状態の振る舞いに関して
```python
@app.route('/pipe')
def pipe():
    if request.environ.get('wsgi.websocket'):
        ws = request.environ['wsgi.websocket']
        while True:
            # ここに game.py の内容を書く．コマンド入力が欲しいときは message = ws.receive() で入力待ち状態に移行する．
            print("message 受信前")
            message = ws.receive()
            print("message 受信後")
            print(message)
            # ws.send("test message")
    return
```
こうすると，
`message = ws.receive()`
の箇所で，message 受信前のメッセージが出てストップする．ので，入力待ち状態に入っていることがわかる．

- スクリプトファイルの実行とディレクトリ構造に関して

`code1.py`
```python
# import だけで 同階層にある code2 の スクリプトが実行される
import code2

# 関数を呼び出す場合はいつも通り
code2.fun1()

# 別階層のスクリプトを実行する場合
import testcode.code3

# 別階層のファイルの変数を参照する場合．
print(testcode.code3.cd3)
```
`ディレクトリ構造`
```
TestProject
|--code1.py
|--code2.py
|--testcode
|  |--code3.py
```
- 次回修正するエラー
    - `server.py` に `game.py` のゲーム処理をコピーしたけど，実行されるのは`pipe()` 関数なので，スコープの問題で `not defined` になる．
    - `game.py` の処理をまるごと関数にして，引数に ws をとったらどう？

### 8/28 後半
>- 次回修正するエラー
>    - `server.py` に `game.py` のゲーム処理をコピーしたけど，実行されるのは`pipe()` 関数なので，スコープの問題で `not defined` になる．
>    - `game.py` の処理をまるごと関数にして，引数に ws をとったらどう？
- クラス定義やらゲーム処理やらを全部 main 関数にまとめたら解決。python のスコープの問題だった。
- html のボタンと server 側のコマンドを結びつけた。
    - ブラウザ上で hit stand コマンドを入力可能になった
    - hit stand 以外のコマンドは次回追加する。
- 次回
    - ほかのボタンの実装。
    - ターミナルに表示される内容をブラウザ上で表できるようにする。

### 8/29
- ダブル、サレンダーボタンの実装。
    - js 内のオンクリック関数を `action` に統一した。　
    - 他の特定条件下で発動するスプリット、インシュランスはボタン表示バリデーションを実装してから追加する。
- ブラウザ上で手札を表示できるようにした
    - とりあえず文字列でスートを表現した。(♥1, ♠10, みたいな感じ)
    - 簡単な画像にする場合は js 内の関数を編集することで可能。
    - **フロント側は サーバーからデータを受け取ることをトリガーに HTML の内容を書き換えるようにしてある。**
        - ので、サーバーは手札が更新されることをトリガーにしてフロント側へ json を投げる処理を作ればよい。
- マルチプレイ対応させようとしてたけど、そもそもブラックジャックでマルチである必要ある？
    - 必要ないが、ポーカーに対応させたかったり、マルチプレイの仕組みの理解を深めたいから実装する方向でいく。
    - もし、シングルプレイのみの実装になった場合、プレイヤーが BJ の時にディーラーがaction する仕様を修正しないといけない。

### 8/30
- やったこと
    - 間違ったボタンを押したとき、反応しないように `wait_input` 関数を作った。
    - プレイヤーのハンド、ディーラーのハンド、結果を html 上に表示されるようにした
    - 結果の表示に伴って、送信する json の内容を変更した。(詳しくは `server.py` に書いてる)
- 次回やること
    - スプリット、インシュランス可能時に、どうしますか？的なメッセージ表示
    - ゲーム進行中のハンドの表示(スプリットの表示方法を考えないといけない)
    - スプリット時 json データの処理方法に関して考える

### 9/1
- やること
    - スプリット、インシュランス可能時に、どうしますか？的なメッセージ表示機能の実装
        - json に pop_message を追加してメッセージがあるとき(答えが yes/no) ブラウザに表示させるようにした。
    - ゲーム進行中のハンドの表示(スプリットの表示方法を考えないといけない)
        - スプリットの場合、json に `is_split_hand = True` を送ることでフロント側で スプリット
        してるハンドだと判断して表示する。(サーバー側は `p.hand[hand_num]` みたいにする必要はなく、`is_split_hand` と `p.hand` を送れば ok)
- 今後やるべきこと
    - 所持金の表示、bet額の入力
    - ボタン入力バリデーション (フロントサイドで実行できないアクションボタンは非表示にする。)
    - デッキシャッフルイベントの追加
    - カード画像の表示

### 9/2
- やったこと
    - トップページの実装、名前入力フォームの実装。
    - パスワード認証(簡単に) 実装したいが、**一つ疑問点**
        1. ユーザーがブラウザにパスワードを入力し、**ブラウザはサーバーに平文で送信**、**サーバー側がパスワードをハッシュ化し、DB に保存**
        2. ユーザーがブラウザにパスワードを入力し、**ブラウザ(js)がパスワードをハッシュ化**して、送信、**サーバー側は**送られてきた**ハッシュ化済みのパスワードを DB に保存**
        - 1 と 2 でどっちが正しい？(どちらがよりセキュアなのか)
        - よく見る実装は、1だが、1はリプレイアタックに弱すぎる気がする
            - リプレイアタックの対策にはチャレンジレスポンス認証が取られるが、そもそも 2 で、ソルト含んでハッシュ化したら OK なのではないのか
                - (もしかして、これがチャレンジレスポンス認証？？)
    - firestore 連携のテストコード作成。
        - 多分あるやろうけど、フィールド制約(キー制約)のつけ方がわからんかった。
- 今後やるべきこと
    - 所持金の表示、bet額の入力
    - ボタン入力バリデーション (フロントサイドで実行できないアクションボタンは**非表示にする。**)
    - デッキシャッフルイベントの追加
    - カード画像の表示

### 9/4
- やったこと
    - ボタン入力バリデーション (フロントサイドで実行できないアクションボタンは**非表示にする。**)
        - 入力できないボタンのインアクティベート化
        - 入力できるアクション(押せるボタン)の情報をフロント側に送信
    - ゲーム終了ボタンを押した時の確認ダイアログの表示
        - はいを選択でトップ(ログイン)画面に戻るようにした．
- 今後やること
    - 所持金の表示、bet額の入力
    - デッキシャッフルイベントの追加
    - カード画像の表示
    - スプリット時に結果が１パターンしか表示されていないので，手札ごとに結果を表示する
    - スプリット時にどっちの手札に対するアクションなのか示す．
- 検討中
    - `send_json()` が大きくなってきてるので，メッセージ送る関数と手札配列送る関数を別にしてもいいかも．

### 9/5
- やったこと
    - `send_json()` のリファクタリング．`create_active_button_dictionary()` を作ってフラグを代入する処理を別関数に移植した
- 今後やること
    - 上と同じ
- 検討中
    - 送信する json データをクラスでまとめてモデル化してもいいかも
        - やるとしてもリファクタリングは後回しにしたい．

### 9/6
- やったこと
    - 所持金の表示, bet額の入力
        - json テンプレの変更。
        - bet 金額入力選択時に、ゲームボタンを非表示にした。
        - 逆に、ゲーム進行時には、bet ボタンを非表示にした
    - デッキシャッフルイベントの追加
- 今後やること
    - インシュランス時のディーラーのマスクする手札が間違ってる
    - カード画像の表示
    - スプリット時に結果が１パターンしか表示されていないので，手札ごとに結果を表示する
    - スプリット時にどっちの手札に対するアクションなのか示す．
    - 結果をDBに保存
    - シャッフルしたよメッセージ
- その他
    - VScode のターミナルで実行して、ストップしないままターミナルを閉じるとプロセスが実行されたままになってしまう問題
        - powershell では、`Get-Process -Name python` と叩くと python のプロセス一覧を取得できる。
        - `Stop-Precess -Id XXXX` で、-Id のプロセスを kill できる。

### 9/7
- やったこと
    - スプリット時にどっちの手札に対するアクションなのか示す．
    - スプリット時に結果が１パターンしか表示されていないので，手札ごとに結果を表示する
    - インシュランス時のディーラーのマスクする手札が間違ってる
- 今後やること
    - カード画像の表示、フロントデザイン
    - 結果をDBに保存
    - シャッフルしたよメッセージ

### 9/8 前半
- やったこと
    - firestore連携
        - hrml 上で入力されたユーザが、DB 上に存在するかチェックする関数を実装した
            - なかった場合、testuser で仮ログイン
            - ある場合、そのままログインできるようになってる
- 今後やること
    - カード画像の表示、フロントデザイン
    - シャッフルしたよメッセージ
    - パスワードのハッシュ化
    - 結果をDBに保存
    - ゲーム結果からバンクロールの更新
    - ログアウト画面
- その他
    - `main.py` から他の `ファイルA.py` を読むとき、`ファイルA.py` から `ファイルB.py` を読んでる場合、パスが `main.py` から見たパスになる問題
    - これは `main.py` からのパスをそのままでいいのか、良い方法があるのかどうなの
    - [Python で自作モジュールを扱うときに困ったこと](https://qiita.com/naz_/items/62d10ea9dd24e232d18f)
        - 一応解決策は書いてるけど、VScode ではエラー判定になる。(赤くなるだけで、実行できる)
        - Vscode の仕様っぽいから、無視したほうがいいかも？

### 9/8 後半
- ~~ユーザ情報の name はユニークにする。~~
    - ~~セッションで name を管理することでバンクロールとかプレイ履歴を更新したり取得したりする~~
    - やっぱりやめた！ユニークにするのがめんどくさそうだったので、元からユニークな firestore の ドキュメントID を使うことにした。
- やったこと
    - 結果をDBに保存
    - ゲーム結果からバンクロールの更新
- 今後やること
    - カード画像の表示、フロントデザイン
    - シャッフルしたよメッセージ
    - パスワードのハッシュ化
    - ログアウト画面

## 今回の反省点
- プレイヤークラスの肥大化
    - 手続き的な処理 (キー入力、ゲームの流れ、スプリット後に二回ヒットできないなど) を一緒に書いてしまった。
    - 手続き処理は `main()` に書いて、プレイヤークラスはシンプルにしたほうがよかった。
        - 逆に `Deck` クラスはシンプルで、ほかのカードゲームにも流用できそうでいいと思う。 
- コマンドラインのブラックジャックから作ったこと
    - フロントと socket のイメージが固まってないままゲームを完成させたので、変更しにくい。
    - 徐々にフレームから作っていくのが効率よいのかなと思った。